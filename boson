#!/usr/bin/env python3

import yaml
import sys
import os
import logging
from sqlalchemy import create_engine, Table, Column, Integer, String, Numeric, MetaData, ForeignKey, Sequence
from sqlalchemy.sql import table, column, select, update, insert
from pprint import pprint as pp

class DB(object):
    """ Singleton Encapsulation of the database connection """
    __instance = None

    def __new__(cls):
        if DB.__instance is None:
            DB.__instance = object.__new__(cls)
            with open('database.yml', 'r') as f:
                db_config = yaml.load(f)
            env = os.getenv('BOSON_ENV', 'development')
            connection_string = db_config[env]
            logging.debug("connecting to " + connection_string)
            DB.__instance.engine = create_engine(connection_string)
            DB.__instance.connection = DB.__instance.engine.connect()
        
        return DB.__instance



class ScriptRunner(object):
    """Understands how to parse and execute boson scripts"""

    def __init__(self):
        pass

    def interpret(self, script):
        # TODO: validate script syntax
        for task in script:
            self.dispatch(task)
    
    def dispatch(self, task_definition):
        task_class = getattr(sys.modules[__name__], (task_definition['action'] + '_action').replace('-','_').capitalize())
        task = task_class(task_definition)
        logging.info('EXECUTING: ' + task_definition['description'])
        task.execute()


class Create_list_action():
    """ Understands how to instantiate a list """

    def __init__(self, definition):
        self._definition = definition

    def execute(self):
        self._create()

    def _create(self):
        metadata = MetaData()
        table = Table(
            self._definition['name'],
            metadata,
            *self._columns()
        )
        metadata.create_all(DB().engine)

    def _columns(self):
        columns = list()
        for c in self._definition['attributes']:
            columns.append(Column(c['name'], getattr(sys.modules[__name__], c['type'].replace('-','_').capitalize())))
        columns.insert(0,Column('name', String))
        columns.insert(0,Column('id', Integer, Sequence(self._definition['name'] + '_id_seq'), primary_key=True))
        return columns

class Update_list_action():
    """ Understands how to update a list """

    def __init__(self, definition):
        self._definition = definition
        self._metadata = MetaData(bind=DB().engine)
        self._mytable = Table(self._definition['name'], self._metadata, autoload=True)

    def execute(self):
        for value in self._definition['values']:
            s = self._mytable.select().where(self._mytable.c.name==value['name'])
            result = DB().connection.execute(s)
            logging.debug('returns_rows = ' + str(result.returns_rows))
            value_exists = False
            for row in result:
                value_exists = True
            self._update(value) if value_exists else self._insert(value)

    def _update(self, value):
        s = update(self._mytable).\
            where(self._mytable.c.name == value['name']).\
            values(value)
        DB().connection.execute(s)

    def _insert(self, value):
        s = self._mytable.insert().values(value)
        DB().connection.execute(s)


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

    with open(sys.argv[1], 'r') as f:
        script = yaml.load(f)

    s = ScriptRunner()
    s.interpret(script)
    logging.shutdown()